---
title: "Better Programming"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---
load libraries 
```{r}
library(purrr)
library(tidyverse)
```

## map()

```{r}
set.seed(10)
my_list <- list(rnorm(100), runif(10), rgamma(40, shape = 1, rate = 1))
map(my_list, mean)
```

map allows for short hand lets compare map() and lapply()
```{r}
# grab the 2nd element from each list element 
map(my_list, 2)
```

with lapply()
```{r}
lapply(my_list, function(x) x[[2]])
```

another way 
```{r}
lapply(my_list, `[[`, 2)
```

purr functions also give shorthand way to create anonymous functions 
```{r}
map(my_list, \(x) mean(x))
```

```{r}
map(my_list, \(x) max(x)-min(x))
```

map_*() - allows you to specify the type of outputs 
```{r}
map_dbl(my_list, mean) # returns a vector
```

map2() - allows you to apply a function to two similar lists (returns a list)
```{r}
my_list_2 <- list(rnorm(100), runif(10), rgamma(40, shape = 1, rate = 1))
map2(my_list, my_list_2, \(x,y) mean(x)-mean(y))
```

pmap() - extends the idea to an arbitrary number of files
```{r}
my_list_3 <- list(rnorm(100), runif(10), rgamma(40, shape = 1, rate = 1))
pmap(list(my_list, my_list_2, my_list_3),
     \(x, y, z) (mean(x)-mean(y))/ mean(z))
```

walk() - allows you to use a side-effect function but return the original data 
a side effect function is a function that doesnt change the data it just produces something some examples are print(), read_csv(), and plot()
```{r}
#just apply the function
par(mfrow = c(1,3))
my_list |>
  map(hist)
```

```{r}
par(mfrow = c(1,3))
#now with walk() function 
my_list |>
  walk(hist) |>
  map_dbl(mean)
```

## List Columns 

```{r}
iris |>
  as_tibble() |>
  mutate(diffs = pmap(list(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width),
                      \ (x,y,z,w) list(x-y, x-z, x-w))) |>
  select(diffs, everything())
```

pull() - to get a paricular column out of a dataframe
```{r}
iris |>
  as_tibble() |>
  mutate(diffs = pmap(list(Sepal.Length, Sepal.Width, Petal.Length, Petal.Width),
                      \ (x,y,z,w) list(x-y, x-z, x-w))) |>
  select(diffs, everything()) |>
  pull(diffs)
```

another example 
```{r}
library(httr)
library(jsonlite)
game_info <- GET("https://api-web.nhle.com/v1/score/2024-04-04") |>
  content("text") |> 
  fromJSON(flatten = TRUE, simplifyDataFrame = TRUE) |>
  pluck("games")
```

check out the structure
```{r}
str(game_info, max.level = 1)
```

pull out the tv broadcast column 
```{r}
game_info$tvBroadcasts
```

add a column 
```{r}
game_info |>
  mutate(num_networks = map(tvBroadcasts, nrow)) |>
  select(num_networks, tvBroadcasts, everything())
```

## Advanced Function Writing

unnamed arguments consider data.frame
```{r}
data.frame
```

looking at a function from previous notes
```{r}
standardize <- function(vector, center = TRUE, scale = TRUE) {
  mean <- mean(vector)
  stdev <- sd(vector)
  if(center) {
    vector <- vector - mean
  }
  if(scale) {
    vector <- vector/stdev
  }
}
```

using ... as an argument 
```{r}
standardize <- function(vector, center = TRUE, scale = TRUE, ...) {
  mean <- mean(vector, ...)
  stdev <- sd(vector, ...)
  if(center) {
    vector <- vector - mean
  }
  if(scale) {
    vector <- vector/stdev
  }
  return(list(result = vector, mean = mean, sd = stdev))
}
```

apply our function to data 
```{r}
#Ozone has some missing data
airquality$Ozone
```

can add to our standardize function 
```{r}
standard_Ozone <- standardize(airquality$Ozone, na.rm = TRUE)
 standard_Ozone$mean
```

```{r}
standard_Ozone$sd
```

dealing with ... 
```{r}
#you can get at the unnamed argument with list(...)
 f <- function(x, ...){
    unnamed <- list(...)
    modifyX <- x^2
    return(list(newX = modifyX, elipses_names = unnamed))
 }
 f(x = 10, a = 1, b = list(char = "hey there", num = 1:3))
```

alternatively you can use the names() function 
```{r}
 f <- function(x, ...){
    unnamed <- names(list(...))
    modifyX <- x^2
    return(list(newX = modifyX, elipses_names = unnamed))
 }
 f(x = 10, a = 1, b = list(char = "hey there", num = 1:3))
```

function to find group means 
```{r}
iris |>
  group_by(Species) |>
  summarize(across(where(is.numeric), 
                   list("mean" = mean), 
                   .names = "{.fn}_{.col}"))
```

selecting columns in tidy style functions 
1. using enquo with !!() (injection operator)
```{r}
find_group_mean <- function(.df, group){
  group_name <- enquo(group)
  .df |>
    group_by(!!group_name) |>
    summarize(across(where(is.numeric), 
                     list("mean" = mean), 
                     .names = "{.fn}_{.col}"))
}
find_group_mean(iris, Species)
```

2. using {{}}
```{r}
find_group_mean <- function(.df, group){
  .df |>
    group_by({{group}}) |>
    summarize(across(where(is.numeric), 
                     list("mean" = mean), 
                     .names = "{.fn}_{.col}"))
}
find_group_mean(iris, Species)
```

we can allow for multiple columns with ... 
must use quos() and !!!() instead 
```{r}
find_group_mean <- function(.df, ...){
  group_vars <- quos(...)
  .df |>
    group_by(!!!group_vars) |>
    summarize(across(where(is.numeric), 
                     list("mean" = mean), 
                     .names = "{.fn}_{.col}"))
}
find_group_mean(CO2, Type, Treatment)
```

as_label for tidyverse style functions 
we may want to name a variable using a column passed 
as(label) can be used
must use "Walrus" operator, :=
```{r}
find_group_mean <- function(.df, group, column){
  group_name <- enquo(group)
  column_name <- enquo(column)
  column_label <- paste0("mean_", as_label(column_name))
  .df |>
    group_by(!!group_name) |>
    summarize(!!(column_label) := mean(!!column_name))
}
find_group_mean(iris, Species, Sepal.Length)
```

## Pipeable functions 

example: side-effect function to print info
```{r}
print_num_obs <- function(.df) {
    cat("The number of observations in the data set is ", 
        nrow(.df), 
        "\n", 
        sep = "")
  invisible(.df)
}
iris |> 
  print_num_obs() |>
  summarize(mean = mean(Sepal.Length))
```

## Lazy evaluation 
R evaluates arguments only when needed 
- force the evaluation by writing the argument or force(arg)
consider the silly function below 
```{r}
run <- function(x){
  force(x) #or just x, this just makes it explicit it wasn't a typo!
  3
}
run(stop("stop now!"))
```

## Lazy Evalution on Comparisons 
```{r}
x <- NULL
x > 0
## logical(0)
if(x > 0){
  print("hey")
}
## Error in if (x > 0) {: argument is of length zero
!is.null(x)
## [1] FALSE
if (!is.null(x) && x > 0) {
  print("hey")
}
```

## Environments and Lexical Scoping
```{r}
library(pryr) #install if needed
x <- "hey"
where("x")
```

```{r}
where("mean")
```

when you call a function, it creates temporary function enviroments 
- this is why variables dont overwrite things. 
```{r}
f <- function(x){
  mean <- paste0(x, " is a value")
  mean
}
f(1:3)
```

```{r}
mean
```

```{r}
g <- function(x) {
  if (!exists("a", inherits = FALSE)) {
    message("Defining a")
    a <- 1
  } else {
    a <- a + 1
  }
  a
}
g(10)
```

```{r}
g(10)
```

```{r}
y <- 10
f <- function(x){
  y <- 1
  x + y
}
f(15)
```

**Important**: if R doesnt find an object in the current environment it will search up the path 
```{r}
y <- 1
f <- function(x){
    x + y
}
f(10)
```

